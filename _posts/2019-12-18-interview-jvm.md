---
layout: post
title: "Java 虚拟机"
subtitle: ' Java 虚拟机相关面试题 '
author: "Song"
header-style: text
tags:
  - jvm
  - java
  - 虚拟机
  - 面试题
---

## 基础知识部分

#### JVM 的主要组成部分及其作用？
#### JVM的内存相关，如何实现？
#### JVM运行时数据区包含哪些？
####说下  JVM 的垃圾回收算法
#### 详细介绍一下 CMS 垃圾回收器？
#### 说下对象创建的 5 个步骤。
#### 怎么判断对象是否可以被回收？
#### 说一下类加载的执行过程？
#### 什么是类加载器，类加载器有哪些?
#### Eden和Survivor的比例分配
#### 什么是 Class 文件？ Class 文件主要的信息结构有哪些？
#### 说下深拷贝和浅拷贝
#### 说下 JVM 四种引用类型
#### 什么是双亲委派模型？
#### 几种常用的内存调试工具：
#### JVM垃圾回收机制，何时触发MinorGC等操作
#### 判断一个对象应该被回收
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 






## 知识进阶部分

#### JVM 年轻代到年老代的晋升过程的判断条件是什么呢
#### 判断一个对象应该被回收
#### 对象什么时候进入老年代？
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 


## 场景分析部分

#### 永久代有内存回收吗？为什么？
#### 说一下堆栈的区别？
#### 队列和栈是什么？有什么区别？
#### JVM 垃圾回收机制，何时触发 MinorGC 等操作
#### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
#### 说一下 jvm 有哪些垃圾回收算法？
#### 说一下 jvm 有哪些垃圾回收器？
#### GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
#### volatile的语义，它修饰的变量一定线程安全吗
#### 什么是内存溢出，内存泄漏？如何阻止内存泄露
#### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？ 有什么办法主动通知虚拟机进行垃圾回收？
#### System.gc() 和 Runtime.gc() 区别。
#### 简述分代垃圾回收器是怎么工作的？
#### GC收集器有哪些？CMS收集器与G1收集器的特点。
#### 什么情况下会出现栈溢出？
#### 什么时候触发 Full 行GC ？
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 
#### 



九、
十、
十一、
十二、
十三、GC的两种判定方法：
十四、类加载的几个过程：
十五、一个对象的内存划分是怎样的？
如何判断对象是否死亡（两种方法）。
简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
如何判断一个常量是废弃常量
如何判断一个类是无用的类
垃圾收集有哪些算法，各自的特点？
HotSpot为什么要分为新生代和老年代？
常见的垃圾回收器有那些？
介绍一下CMS,G1收集器。
Minor Gc和Full GC 有什么不同呢？
对象优先在 eden 区分配

1.2 大对象直接进入老年代
1.3 长期存活的对象将进入老年代
1.4 动态对象年龄判定
2 对象已经死亡？
2.4 不可达的对象并非“非死不可”
2.5 如何判断一个常量是废弃常量
2.6 如何判断一个类是无用的类
3 垃圾收集算法
延伸面试问题： HotSpot为什么要分为新生代和老年代？
4 垃圾收集器

4.1 Serial收集器
4.2 ParNew收集器
4.3 Parallel Scavenge收集器
4.4.Serial Old收集器
4.5 Parallel Old收集器
4.6 CMS收集器
4.7 G1收集器

## 知识扩展部分

#### JVM 调优的工具？
#### 常用的JVM调优参数？



## 说下对象创建的 5 个步骤

- 类加载
- 分配内存
- 内存置零
- 设置对象头
- 初始化其他操作

## 永久代有内存回收吗？为什么？

两个部分明确问题，首先 jdk1.8 之前 Hotspot 才有永久代；其次，永久代有内存回收，只是回收的是常量池和卸载类

## JVM 组成部分

- 运行时数据区
- 类加载器
- 执行引擎
- 本地库接口

程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过一定的方式 类加载器（ClassLoader） 把文件加载到内存中 运行时数据区（Runtime Data Area） ，而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 本地库接口（Native Interface） 来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。

而我们通常所说的jvm组成指的是运行时数据区（Runtime Data Area），因为通常需要程序员调试分析的区域就是“运行时数据区”，或者更具体的来说就是“运行时数据区”里面的Heap（堆）模块，那接下来我们来看运行时数据区（Runtime Data Area）是由哪些模块组成的。

- 结构图和流程可以大致说下。
- 一定得了解针对堆的垃圾回收机制，具体而言，可以画个图，说下年轻代年老代等。
- 说下垃圾回收的流程，然后针对性地说下如何在代码中优化内存性能。
- 最好说下如果出现了OOM异常，该怎么排查？
- 如何看Dump文件。
- GC的一些概念，比如强弱软引用，finalize方法等，这些可以准备下。
- 



194.说一下 jvm 的主要组成部分？及其作用？
195.说一下 jvm 运行时数据区？
196.说一下堆栈的区别？
197.队列和栈是什么？有什么区别？
198.什么是双亲委派模型？
199.说一下类加载的执行过程？
200.怎么判断对象是否可以被回收？
201.java 中都有哪些引用类型？
202.说一下 jvm 有哪些垃圾回收算法？
203.说一下 jvm 有哪些垃圾回收器？
204.详细介绍一下 CMS 垃圾回收器？
205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
206.简述分代垃圾回收器是怎么工作的？
207.说一下 jvm 调优的工具？
208.常用的 jvm 调优的参数都有哪些？


2.JVM的主要组成部分及其作用？
类加载器 ClassLoader：Java代码 -----> 字节码 的编译过程
运行时数据区：把上一步编译得到的字节码加载到内存中
执行引擎：命令解析器，解析上一步加载而来的字节码，翻译成为系统指令，交由CPU执行
本地库接口 Native Interface：诸如IO之类的由其他语言写成的本地库接口
3.JVM运行时数据区包含哪些？
程序计数器：行号指示器，通过改变该值，以选取下一步的指令
Java虚拟机栈：局部变量、方法出口等，为JVM服务
本地方法栈：局部变量、方法出口等，为本地Native方法服务
堆区：内存最大的一块，所有的对象实例都在这里分配内存
方法区：常量、静态变量等
4. JVM垃圾回收机制，何时触发MinorGC等操作
分代垃圾回收机制：不同的对象生命周期不同。把不同生命周期的对象放在不同代上，不同代上采用最合适它的垃圾回收方式进行回收。
JVM中共划分为三个代：年轻代、年老代和持久代，
年轻代：存放所有新生成的对象；
年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象；
持久代：用于存放静态文件，如Java类、方法等。
新生代的垃圾收集器命名为“minor gc”，老生代的GC命名为”Full Gc 或者Major GC”.其中用System.gc()强制执行的是Full Gc.
判断对象是否需要回收的方法有两种：
1.引用计数
当某对象的引用数为0时，便可以进行垃圾收集。
2.对象引用遍历
果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，gc必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。
触发GC（Garbage Collector）的条件：
1)GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。
2)Java堆内存不足时，GC会被调用。
5.JVM的垃圾回收算法：
标记-清除：无用对象全部干掉
标记-整理：有用对象都向一边移动，边界以外的全部干掉
复制算法：左边内存快满时，将其中要保留的对象复制到右边内存中，然后整体干掉左边内存。右边同理，内存利用率仅有一半
分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。
6.JVM 调优的工具？
JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。
• jconsole：用于对 JVM 中的内存、线程和类等进行监控；
• jvisualvm： JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、 gc 变化等。
7.常用的JVM调优参数？
• -Xms2048M最小内存2048M
• -Xmx2048M最大内存2048M
• -XX:NewRatio=4设置年轻的和老年代的内存比例为 1:4
• -XX:SurvivorRatio=8设置新生代 Eden 和 Survivor 比例为 8:2
• -XX:+UseConcMarkSweepGC指定使用 CMS + Serial Old 垃圾回收器组合；
• -XX:+PrintGC开启打印 gc 信息；
• -XX:+PrintGCDetails打印 gc 详细信息。
8.堆栈的区别？
栈内存存储的是局部变量，堆内存存储的是实体；
栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。
9.详细介绍一下 CMS 垃圾回收器？
CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。
CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。
10.怎么判断对象是否可以被回收？
引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。
11.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
12.GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
13.java类加载过程?
14.什么是类加载器，类加载器有哪些?
15.Eden和Survivor的比例分配等
16.volatile的语义，它修饰的变量一定线程安全吗
17.JVM 对象创建步骤流程是什么？
18.什么是 Class 文件？ Class 文件主要的信息结构有哪些？
19.什么是内存溢出，内存泄漏
20.如何阻止内存泄漏？
21.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？ 有什么办法主动通知虚拟机进行垃圾回收？
22.深拷贝和浅拷贝。
23.System.gc() 和 Runtime.gc() 会做什么事情？



二、JVM的内存结构
根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。

Java虚拟机栈：
法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
堆：
线程共享；被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。
方法区：
线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。
程序计数器：
线程私有；是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。
本地方法栈：
线程私有；主要为虚拟机使用到的Native方法服务。
三、GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
先标记，标记完毕之后再清除，效率不高，会产生碎片
复制算法：分为8：1的Eden区和survivor区，就是上面谈到的YGC
标记整理：标记完毕之后，让所有存活的对象向一端移动

四、GC收集器有哪些？CMS收集器与G1收集器的特点。
并行收集器：串行收集器使用一个单独的线程进行收集，GC时服务有停顿时间
串行收集器：次要回收中使用多线程来执行
CMS收集器是基于“标记—清除” 算法实现的，经过多次标记才会被清除
G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的
五、JVM的内存相关，如何实现？
Java堆，Java栈，程序计数器，方法区，1.7的永久代，1.8的metaspace....尽可能多说，顺带简短描述下每个内存区的用途，能想到的都讲出来。

六、几种常用的内存调试工具：
jmap、jstack、jconsole。

七、JVM 年轻代到年老代的晋升过程的判断条件是什么呢
部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。
如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。
minor gc后，survivor仍然放不下，则放到老年代
动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代

八、JVM垃圾回收机制，何时触发MinorGC等操作
当young gen中的eden区分配满的时候触发MinorGC(新生代的空间不够放的时候).

九、判断一个对象应该被回收
该对象没有与GC Roots相连
该对象没有重写finalize()方法或finalize()已经被执行过则直接回收（第一次标记）、否则将对象加入到F-Queue队列中（优先级很低的队列）在这里finalize()方法被执行，之后进行第二次标记，如果对象仍然应该被GC则GC，否则移除队列。 （在finalize方法中，对象很可能和其他 GC Roots中的某一个对象建立了关联，finalize方法只会被调用一次，且不推荐使用finalize方法）
十、什么情况下会出现栈溢出
方法创建了一个很大的对象，如 List，Array。
是否产生了循环调用、死循环。
是否引用了较大的全局变量。



十一、对象什么时候进入老年代？
对象优先在Eden区分配内存
当对象首次创建时, 会放在新生代的 eden 区, 若没有 GC 的介入，会一直在 eden 区，GC 后，是可能进入 survivor 区或者年老代。
大对象直接进入老年代
所谓的大对象是指需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配就是坏消息，尤其是一些朝生夕灭的短命大对象，写程序时应避免。
长期存活的对象进入老年代
虚拟机给每个对象定义了一个对象年龄（Age）计数器，对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1，当他的年龄增加到一定程度（默认是 15 岁）， 就将会被晋升到老年代中。
十二、什么时候触发 Full 行GC ？
调用 System.gc 时，系统建议执 Full GC，但是不必然执行。
老年代空间不足。
方法区空间不足。
通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存。
由 Eden 区、survivor space1（From Space）区向 survivor space2（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
十三、GC的两种判定方法：
引用计数法：
指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为0就会回收但是JVM没有用这种方式，因为无法判定相互循环引用（A引用B,B引用A）的情况
引用链法：
通过一种GC ROOT的对象（方法区中静态变量引用的对象等-static变量）来判断，如果有一条链能够到达GC ROOT就说明，不能到达GC ROOT就说明可以回收

十四、类加载的几个过程：
加载、验证、准备、解析、初始化。然后是使用和卸载了
通过全限定名来加载生成class对象到内存中，然后进行验证这个class文件，包括文件格式校验、元数据验证，字节码校验等。准备是对这个对象分配内存。解析是将符号引用转化为直接引用（指针引用），初始化就是开始执行构造器的代码。

十五、一个对象的内存划分是怎样的？
可分为3块区域：对象头，实例数据，对齐填充

对象头由Mark world和类型指针组成
mark World包括hash码，GC分代年龄，锁状态标志等。
类型指针来确定这个对象是哪个类的实例
实例数据是对象存储的真正的有效信息
hostspot虚拟机要求对象的大小必须是8字节的整数倍


如何判断对象是否死亡（两种方法）。
简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
如何判断一个常量是废弃常量
如何判断一个类是无用的类
垃圾收集有哪些算法，各自的特点？
HotSpot为什么要分为新生代和老年代？
常见的垃圾回收器有那些？
介绍一下CMS,G1收集器。
Minor Gc和Full GC 有什么不同呢？

1 揭开JVM内存分配与回收的神秘面纱

1.1 对象优先在eden区分配

1.2 大对象直接进入老年代
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

为什么要这样呢？

为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

1.3 长期存活的对象将进入老年代
既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

1.4 动态对象年龄判定
为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。

2 对象已经死亡？
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。

2.1 引用计数法

2.2 可达性分析算法

2.3 再谈引用
无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。

JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

2.4 不可达的对象并非“非死不可”
2.5 如何判断一个常量是废弃常量
注意：我们在 可能是把Java内存区域讲的最清楚的一篇文章 也讲了JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

2.6 如何判断一个类是无用的类

3 垃圾收集算法
延伸面试问题： HotSpot为什么要分为新生代和老年代？
4 垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

虽然我们对各个收集器进行比较，但并非了挑选出一个最好的收集器。因为知道现在位置还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。

4.1 Serial收集器
4.2 ParNew收集器
4.3 Parallel Scavenge收集器
4.4.Serial Old收集器
4.5 Parallel Old收集器
4.6 CMS收集器